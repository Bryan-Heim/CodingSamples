##**1653 - Project - Phase 3**
###November 6th, 2016
---

##**Group information**
###Bryan Heim - bph11@pitt.edu
###Richard Dillon - rad114@pitt.edu
---

##Introduction
---
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;During this phase of the project, we spent much time debating and contemplating which cryptographic techniques we could use to secure our system up to the requirements of phase 3. We finally settled on a model that encapsulated features from public key cryptography (using RSA), symmetric key cryptography (using AES),  cryptographically strong hash functions/SHA256 hashes, and the SecureRandom class to generate 20 byte numbers (160 bits of randomness) to be used as challenges. We thought of how we could use these tools to form stronger authentication protocols for both group and file servers, verify token integrity, and ensure that we can protect the system against users trying to snoop or passively monitor the system’s traffic. We decided on introducing a small-key generator program that will create a 4096-bit RSA private/public key pair, each key in their own respective PEM file, such that each user can generate their own keys before registering for and interacting with the system. This key generator will be supplied with the client application and will allow the authentication of users to happen. Using all of these tools, we can address the four specific threats in detail and show how the system’s security will be maintained against these threats. The four cases are as follows: 

##1. Unauthorized Token Issuance
---
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The key component to interacting with the system is the user’s token. Tokens allow us to know who a particular person is, what groups/files they have access too, and what server authorized the issuance of that token to that specific person. It is vital for the system’s security that we only issue a user his/her token once we are one hundred percent certain that the user’s identity is confirmed. Because we have assumed that clients can be anyone and that they cannot be trusted, we must ensure that we only give the correct tokens to people who are properly authenticated such that we know with certainty that they are who they say they are. If a malicious client is able to access tokens that do not belong to them, they can exploit this to gain privileges to various groups/files. In the worst case, the malicious user will be able to get a token from the group server that belongs to user with administrative privileges (belonging to the ADMIN group) which would allow the user to have unauthorized access all of the functionality of the system. If the group server is not actively monitored or logged, this also opens up the potential to introduce a backdoor for the malicious user to then exploit the system at any later given time by creating a new user for themselves and granting themselves escalated privileges. We can mitigate these negative effects if we only issue the correct token to the correct users who have properly proved their identity and can then be trusted. In order to this, we can apply the techniques of public key cryptography and symmetric key cryptography that will allow the group sever to authenticate a user before granting him/her a token (system access) and then authenticating the server to user.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When the system is first started, the admin/owner will have to create two sets of 4096-bit RSA public private key pairs (one pair for the group sever named “gs-pubK.pem” and “gs-privK.pem”, one pair for the admin/owner named “user-(first username)-pubK.pem” and “user-(first username)-privK.pem” using the provided key pair generator program. The group server will contain a directory with all users’ current public keys named “UserPubKeys” and also contain a directory for its own private public keys named “SystemKeys”. Before a new user is added to the system, their public key file is downloaded and verified via a phone call and then placed on the group server in “UserPubKeys”. When the user is created, their public key file will become associated with their username even if the key file is changed/updated. When the client attempts to access the group server to gain a token, the group server will first generate a random 256-bit AES key that will use randomly generated 16 byte start IV’s, Cipher block chaining (CBC), and PKCS7 padding and a random, one time use challenge number created with the SecureRandom java class. It will then compute the SHA256 hash of the AES key concatenated with the random number and will encrypt the AES key using the client’s stored public key and send that cipher text as well as the random challenge back to the client. The client must then decrypt the AES key, generate the same SHA256 hash,  their own single use random number encrypted with the server’s public key, and send the hash and encrypted challenged back to the server. The server can check that hash and exit or return the second random challenge allowing both parties to properly authenticate each other. The process would appear as follows with Kas being the server generated AES key for Alice and the server’s session, R1 being the client’s challenge, ka being alices public key, ka^-1 being alices private key, ks being the group server’s public key, ks^-1 being the servers private key, R2 being the server’s challenge, and 4096-bit RSA where all keys are RSA 4096-bit keys and the challenges are a single use generated SecureRandom number:<br /><p align="center">![alt text](https://github.com/Bryan-Heim/cs1653-2016fa-bph11-rad114/raw/master/images/T1Handshake.png "T1 Handshake Protocol")</p>
 
##2. Token Modification/Forgery
---
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;After we are able to properly authenticate the users connected to the group server, we are able to issue them a token. Even though we can be certain we gave the right token to the right user, we don’t want the users to be able to edit their own tokens once issued one from the group server. This would pose several threats to the systems security. It could allow for many of the aforementioned problems by allowing users to change what the token lists for their username or their lists of groups. If we did not check to verify that a user’s token was not modified, a malicious user would be able to manipulate his/her own token, even possibly mimicking another users token altogether. Therefore, for the sake of overall system security, we should guarantee the integrity of all user tokens. If there is evidence that a user’s token was tampered, then the entire token should be considered invalid and the user should not be able to interact with the system until he/she has received a genuine token again from the group server. In order to maintain the data integrity of the tokens, we can use cryptographically strong hash functions and digital signatures to compute our verification.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Because different architecture sets (x86, ARM, Sparc, etc.) have different ways of representing data, we cannot simply convert the token into a byte array. This is because of the fact that if we were to convert the information to a byte array, different architecture sets may produce different hashes for the correct information. Instead, what we can do is use the information contained within the token and we can instantiated a new string that will contain which server issued the token, which user the token was for, and a list of all of the groups as strings, all concatenated together. By doing this we can encapsulate all of the needed data contained within the token into a single variable. Because this string may be long, dependent on how many groups the user is in, we can take the concatenated string and calculate the SHA256 hash of this string. However, we must consider two things about the string and the hash that it will produce. Malicious users may attempt to concatenate a username and first group or different groups, which would result in correct hashes for tampered data. To overcome this we can introduce a sentinel value, “\0” or null, to mark the end of the username and each group, which will result in different hashes if the user attempts to create these malformed concatenations. The second thing we must consider is that the order of the groups does not matter in the token, but different ordering can result in different resultant hashes. To overcome this particular case, we can simply force that before we concatenate a user’s entire group together, we can sort the list to be in alphabetical order. This will ensure that all group combinations that are the same will have the same resultant hash. We can then use this sign the hash with a digital signature using the group server’s private key. This will ensure the integrity of the hash has not been tampered or changed because anyone can verify that the signature is correct using the group server’s public key. We can then add this signed SHA256 hash to the token itself and send it to the user. When a user attempts to use any of the commands on either the group server or the file servers, the server can parse the signed hash out of the user’s token and verify that it using the group server’s public key. It can then recreate the string that was hashed by parsing the rest of the information in the token, concatenating the string values together, and computing the SHA256 hash. If the newly computed hash matches the hash that was parsed and verified then we know that the integrity of the token has been upheld. If the hashes do not match or the signature cannot be verified, then we cannot say that the token has not been changed and we can reject any actions from that token until the user has received a correct token from the group server.

##3. Unauthorized File Servers
---
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Proper authentication of file servers is essential for security of our group-based file sharing application.  Without properly authenticating a server, anybody could essentially pretend to be a server and thereby gain access to potentially sensitive information.  If anybody could ‘properly authenticate’ their machine as a file server, and if the user were to trust that, the user would then upload files that could be of sensitive information.  For example, if this application were something like pirate bay, and the government were to act as a file server, users could ‘properly authenticate’ to government machines. By authenticating themselves as a server in the system, the government could then run operations to find and arrest anyone that uploads a file of stolen software or eBooks on their servers.  My mechanism to solve this problem is to have a handshake protocol with the file server in question prior to uploading / downloading files on the server.  In the above threat example, trying to connect to the government server still looks fishy, but no incriminating files will be uploaded or downloaded, so no solid evidence!<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The handshake protocol works as follows. The client starts the handshake by generating a 256-bit AES key using BouncyCastle as a provider for the Java JCE, and a random challenge using SecureRandom.  The random challenge generated here is used for freshness in each handshake.  After generating the shared symmetric key and the random challenge, the client then computes the SHA256 hash of the AES key and the random challenge, and stores the hash locally.  The user then retrieves the server’s public key file either through an online CA, email with the server host, or via a flash drive given to the user.  The client then computes the SHA256 hash of the server’s public key given in that file, and displays it to the user.  The user then authenticates the public key hash with the server host via phone call.  This step is optional as it cannot be enforced, but provides added guarantee that the public key is indeed the server’s public key and not an attacker’s public key.  The server’s public key is then used to encrypt the 256-bit AES key concatenated with the random challenge.  The encrypted AES key and random challenge are then sent to the server.  After receiving the encrypted message from the client, the server decrypts the message using its private key, and retrieves the AES key and the random challenge.  Since the server is the only entity that has knowledge of the matching private key to its public key, we ensure that the server and the client are the only two machines that have knowledge of the random challenge and the AES key.  The server then computes the SHA256 hash of the AES key and the random challenge received from the client.  That hash is then sent back to the client for authentication.  Upon receiving the hash from the server, the client compares the received hash with the previously computed hash.  If the hashes match, then the client has authenticated the server.  If they do not match, the session is terminated, and the client must restart the handshake to authenticate the server. The diagram below represents this handshake protocol: <br /> <p align="center">![alt text](https://github.com/Bryan-Heim/cs1653-2016fa-bph11-rad114/raw/master/images/T3Handshake.png "T3 Handshake Protocol")</p>

##4. Information Leakage via Passive Monitoring
---
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;It is essential that files remain hidden from snoopers on public networks for this file sharing application to be useful.  For example, if this file sharing application were to be deployed by a government organization such as the NSA, documents would need to stay secure.  Imagine if specs of our nuclear system were sent over an open network, unencrypted.  The price for such a mistake would be our National Security. All communications, after authentication, with a file server will be done using the 256-bit AES key transferred in T1 or T3’s protocol.  That AES key will be used with CBC and PKCS7 padding.  Since the AES key is a throw away, generated at the start of every client-server session, it provides perfect security for file transfers, and also provides forward security for future client-server sessions.  CBC will be used because it is the most efficient way to transfer potentially large files. Since only the two parties present in the previous handshake protocol know the secret AES key, this will provide perfect security for all transmissions post handshake. Since hashes have the property of preimage resistance, and we are using the SHA256 hash in T3, no information about the shared key is ever revealed.  Since CBC is used, blocks in transmission are not susceptible to replay or reflection attacks, and an attacker does not have many cipher text/plaintext pairs to launch an offline attack.  Actual application of the AES key in CBC mode will be done using SealedObjects.  SealedObjects take in a Cipher, and encrypts an object using that Cipher.  The object is then sent along an ObjectOutputStream to be picked up by whoever is listening.  The SealedObject can be picked up by whoever is listening, but the only way to retreived the actual Object from the SealedObject is to provide the correct decryption Cipher.  Since the correct decryption Cipher needs the same AES key as was used in encryption, it is my belief that this method of communication works to satisfy the problem given in T4.

##Conclusion
---
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In conclusion, we have reached a point at which we feel the system can be secure given the a priory assumptions that users can generate their own keys, give them to the group server or file server before first access, verify that the key stored on the server is correct and the same as the user generated one. We would also be able to update the public key directory if a user’s key must be changed or updated. We did have much deliberation on various components of the system before reaching these agreed upon protocols. We thought of different ways of storing passwords and generating strong passwords from weak ones, whether or not we should pass the shared AES keys over the public channel using Diffie Hellman after we have authenticated, whether or not we should give the user only a hash of the token to avoid a small but potentially dangerous attack where someone could perfectly mimic another users token such that could pass the hash vs hash comparison, etc.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; We finally concluded that what we have designed would work perfect for a corporate setting that has a variety of different teams/groups (engineering, marketing, accounting, etc.) that are all working on different projects. Users generate their own private and public RSA keys (which can be done by the employer during hiring), can load the public key files into a directory on the group server and verify with the employee that they are the same key, do the same with each file server the employee will need access to and will be ready to interact with the system. The group and file servers can have their own generated RSA key pairs that live on the server machine itself and whose public keys can be posted to a company bulletin. Users can properly authenticate themselves to group server and gain the proper token using their private key file and the also authenticate the group server by having it decrypt a challenge that was encrypted using the server’s public key. They will not be able to modify their token to see what other groups or teams are working on or impersonate another co-worker because their token’s hash will be constantly compared. File servers will have the flexibility to be added as needed by either teams or groups or even individual users working on a specific project. These file servers can add the public keys of the other employees that need access to the system and maintain proper authentication before allowing access. Lastly, all of this communication can happen over a public network but will ensure the confidentiality of the company’s intellectual property because all of the input/output responses will be encrypted using a shared, single session 256-bit AES key that is exchanged during authentication.