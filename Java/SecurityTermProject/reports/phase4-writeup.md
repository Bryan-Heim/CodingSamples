##**1653 - Project - Phase 4**
###November 27th, 2016
---

##**Group information**
###Bryan Heim - bph11@pitt.edu
###Richard Dillon - rad114@pitt.edu
---

##Introduction
---
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;During this phase of the project, we spent much time debating and contemplating which cryptographic techniques we could use to secure our system up to the requirements of phase 4. We finally settled on a model that encapsulated features from symmetric key cryptography (using AES), cryptographic checksums (HMAC), using cryptographically strong hash functions (SHA-256), digital siganatures via RSA, and finally a keychain tool (Hashtable of groups to SecretKeys lists).  We thought of how we could use these tools to ensure that files could not be leaked by servers, tokens cannot be stolen by any file server, and communications between servers and users cannot be altered in any way by an active attacker to produce meaningful changes of server state.  We decided on introducing an integrity key to be used in both communicating with a file server, and communicating with a group server.  The purpose of such a key is to be used with an HMAC to enforce message integrity (i.e. prevent changes in a message, and message replays).  We also decided to use group AES keys to encrypt files sent to file servers so that the data stored on actual file servers is unreadable by them.  Therefore, if a file is leaked by a malicious server, it is unreadable to because they would not possess the key!  Using all of these tools, we can address the three specific threats in detail and show how the system’s security will be maintained against these threats. The three cases are as follows: 

##T5. Message Reorder, Replay, or Modification
---
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In order to provide a perfectly secure system, it is imperative that policies be put in place to prevent a number of attacks.  These include replay attacks, reordering of messages in transit, and altering messages in transit.  If these attacks were allowed to occur on a file-sharing application such as this, files could get corrupted, or messages can be sent undenounced to the user.  For example, there could be a message sent to a file server by a user that contains a file to be uploaded to the server.  If that message were to be altered prior to being received by the server, a file could be successfully uploaded to the server containing altered data.  If the message was saved and replayed at a later date, and the original copy was deleted, the message could then be saved on the server even though it was previously deleted by a user.  These are just a couple minor examples of misconduct that could result in real, unintended, changes on the file server.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;As stated in the above paragraph, our system is vulnerable to attacks that replay or reorder messages sent to servers after authentication.  In order to solve this problem, we can have message synchronization between both the server and the user.  If both the server and user keep track of the number of messages currently sent between both parties, they each know what message number to expect from the other party next.  Therefore, we can detect reordering of messages because the expectation will not match the actual received message number.  To achieve this in the current version of our file sharing system, we can have both the server and the client keep an integer counter representing the message number.  Whenever an envelope is sent by either party, their respective counter will be included in the encrypted envelope, and after the message is sent, the counter is incremented by 1.  Whenever an envelope is received by either party, their respective current counter is compared to the decrypted counter in the envelope.  If they are the same, then no reordering or replay occurred.  Likewise, if they are different, that is evidence of replay or reordering of messages, and the session is dropped.  After the comparison is done, and there is no evidence of message replay or reordering attacks, the current counter is incremented by 1.  All encryptions and decryptions are done using the 256-bit AES session key that is passed during the initial handshake, along with CBC and PKCS7 padding.  Here is an example of an envelope sent to a server:  (Kc is the confidentiality session key) <br /> <p align="center">![alt text](https://github.com/Bryan-Heim/cs1653-2016fa-bph11-rad114/raw/master/images/T5hmac1.png "Figure 1")</p>Once an envelope is received, the encrypted counter is compared to the counter stored on the server.  If they match, then the envelope is valid.  If they don’t match, then the envelope is invalid and the connection is dropped.  The server’s counter is then incremented upon receiving a valid message.  The same is done when envelopes are sent to clients, as clients also maintain a counter.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Our file sharing application is also vulnerable to message tampering in its current state.  In order to defend against such an attack, both servers and users must compute a checksum on the message and send it along with the message.  However, if that checksum is not a cryptographic checksum, then it can be altered by an attacker.  Instead, we will use a cryptographic checksum to ensure that an attacker cannot alter the checksum in a meaningful way without first gaining knowledge of the secret key used in the checksum.  We plan to implement an HMAC as our cryptographic checksum, using a 256-bit AES key passed in the hand shake along with our session key.  The session key as you may recall is also a 256-bit AES key, but will only be used for encrypting messages, while the key discussed here will only be used for computing HMAC’s on the messages.  Specifically, when an envelope is sent by either the user or server, an HMAC is computed using the HmacSHA256 java class with the 256-bit AES key used for HMAC’s.  That HMAC is then sent with the encrypted envelope to the other party.  Upon receiving the envelope, and HMAC, the other party then computes their own HMAC on the decrypted envelope, and compares their computed HMAC to the received HMAC.  If they are different, then the envelope has been tampered with, and the session is dropped. Below is an example of an envelope sent to a server, with its HMAC. (KI is the integrity key used for HMAC’s) <br /> <p align="center">![alt text](https://github.com/Bryan-Heim/cs1653-2016fa-bph11-rad114/raw/master/images/T5hmac2.png "Figure 2")</p>Upon receiving a message like the one above, the server will decrypt the envelope, and then compute an HMAC on it using the shared Integrity key discussed throughout this paragraph.  If the computed HMAC matches the received HMAC, then the message has not been tampered with.  If the computed HMAC does not match the received HMAC, then the message has been tampered with, and the session is dropped.  The same process is done when envelopes are sent to clients as clients also have knowledge of the integrity key.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Our current system is also vulnerable to the replay of an entire session, since the user never proves knowledge of the generated AES keys during the handshake.  There also isn’t an integrity key passed during the handshake that is currently implemented in our system.  Therefore, our handshake will be modified to include both the proof of knowledge from the user, and the 256-bit AES integrity key.  The updated user to file server handshake will be the following:<br /> <p align="center">![alt text](https://github.com/Bryan-Heim/cs1653-2016fa-bph11-rad114/raw/master/images/T5Handshake.png "T5 Handshake Protocol")</p>The group server handshake must also be changed to include an integrity key.  Specifically, during the exchange in T1, a 256-bit AES confidentiality key is generated and encrypted using the user’s public key.  It is then sent from the group server to the user.  During that exchange, a 256-bit AES integrity key will also be generated by the group server and encrypted with the user’s public key.  It too will be sent along with the confidentiality key from the server to the user.  

##T6. File Leakage
---
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;File leaks can have some of the most severe impacts on the security and integrity of the system. The severity is mostly due to the fact that leaking files of various groups and users (all with different rights and permissions) would completely defeat the purpose of attempting to keep the files and the ways of interacting with these files safe and correctly protected. The file servers that contain the files can be setup independently and unbeknownst to the group server (the group server cannot keep track of the various file servers) and it could be the case that some of these servers have bad intentions. They could get various users to interact with it for varying amounts of time and then when they feel the time is right could make any or all of the files on that server publicly available. This would completely circumvent the existence of our secure file sharing system and is a core problem that must be addressed if the system’s overall health and viability are to be sustained.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To prevent file servers from ever leaking a group’s files or all files, we can ensure that the data stored and sent to any one particular file server is encrypted, whose plaintext data is unrecoverable from by the file server. This ensure that even if a file server leaks files, the content of the files will maintain their confidentiality. We must now be careful however about how the encryption process will work when various users are added and removed from a group and whether or not they are able to decrypt files from before they join or after they leave. In our particular system we will only allow users to decrypt files from the time they entered the group and upon being deleted will no longer have access to any future files accessible to that particular group. What all of this means is that when users are added or removed from a group, that group will need a new encryption/decryption key that all of its members can access to easy encrypt files for their group to be safely stored on file servers without the potential for leaked and stolen files.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In our current system implementation we can accomplish this guarantee by using the following strategy. When the group server is first created it must create a new file GroupFileKeys.bin that will be used to store the serializable class GroupFileKeys (provides the user needed capabilities via methods). This file will contain the contents of a Hash table which will act as a master keychain (see figure 1 below) who uses group names (strings) as the key whose value will be an ArrayList of SecretKeys which will be 256-bit AES keys. When a user is added to a particular group or removed from that group (in this model were assuming once removed, your permanently banned) they should not be able to snoop around and see files that belonged to that particular group both before and after they were an active member. On the event that a user is added/removed the group server can generate a new AES key, get the ArrayList of SecretKeys used by that particular group, and add the new key to the appropriate groups’ list. Because we only need to care about changes in the group (not exact times users left or joined) we can use the index of the node in the linked list to mark which sections of keys various uses are allowed to use by storing their join block index and leave block index. We can accomplish this by storing two new Hashtables in each User object in the UserList that take a group name as a key and one will hash to the start block index, the other will hash to the end block index. Users can then ask the group server to give them the keychains of all the groups they are associated with and the group server can retrieve the entire group’s master keychain, select the nodes for which the user would have access to and create a partial keychain, and send those blocks to use as a keychain for encrypting/decrypting. In order for this to happen, a user must have been an active member for some time in the group that he/she wishes to retrieve a chain from.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In practice, when a group is first created, the group is hashed and the new group’s keychain is created and the creator has the start block index set to 0 for their starting block Hashtable. When a user is added or removed, a new AES key is created and added to the group’s list. When a user gets a token to access the system, the group server will create a partial keychain object that will be a Hashtable that takes the groups they belong to as keys and maps to that group’s keychain ArrayList but with Base64 encoded key strings and send this to the user to be used at any file server. Blocks for which a user did not have access to will have a string value of “-1” and thus cannot be used to encrypt/decrypt. When a user wants to upload a file for a group that he/she belongs to, they can go their keychain table, lookup the group’s keychain, go to the last/most recent block, retrieve the key string and convert it into a SecretKey object, and finally use the secret key to encrypt the contents of the files. Along with the contents of the file being stored, we also have to store Meta data that can help point to the key used.  This Meta data includes the group name, the key number, and the IV used when encrypting. Specifically, in our implementation, this data is stored in the SharedFile class with all of the other Meta data pertaining to each file.  When a user wishes to download/view a file, they can determine which block was used and which group the file was shared with by looking up that file’s associated SharedFile in the FileList.  If they were an active member of the group when the file was uploaded, they can traverse their keychain table to get the keychain list of that group, get and create the SecretKey object for the AES key, and then decrypt the received file from the file server. All of this can be done with only requiring the group server to send a keychain table once when a new token is obtained by a user. With their keychain table they can use the above procedures to safely and securely encrypt and decrypt the actual data that is being saved in files on various file servers. Therefore, in this protocol the group server does not need to know about any existing file servers but can provide properly authenticated users the means to ensure the file’s data and contents for the groups which they belong to can be encrypted and stored safely without fear of a leak and still maintaining the capability to share files safe and securely amongst different groups with its other current others. The diagrams below represent what the master keychain table saved and only accessible on the group server (figure 1) and the partial keychain that a user would receive after he/she successfully obtained a token(figure 2):<br /> <p align="center">![alt text](https://github.com/Bryan-Heim/cs1653-2016fa-bph11-rad114/raw/master/images/master-keychain-example.png "Figure 1")</p><br /> <p align="center">![alt text](https://github.com/Bryan-Heim/cs1653-2016fa-bph11-rad114/raw/master/images/user-keychain-example.png "Figure 2")</p>

##T7. Token Theft
---
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In order to properly secure our file-sharing application, a particular user’s token must not be able to be stolen and usable by other users on the system.  If a token were to be stolen, the thief could impersonate the victim by giving the stolen token to a file server, which would then allow the thief to gain access to every file that the victim has access to.  In particular, this section will address the issue of a token being stolen by a properly authenticated file server.  If a file server were to steal a token, it is imperative that the stolen token not be useful outside of the server that it was stolen on.  If it were useful outside of that hijacking server, then any user could set up a file server to steal tokens, and then impersonate anyone that sent their token to that malicious file server.  Essentially the integrity of a token would be worthless.  For example, if this were a file-sharing application for pirated software, and the government set up a file server that could somehow properly authenticate as being a file server on that system, the government would then be able to impersonate any user that tried to access their server.  By impersonating those users, the government would then have access to any file that those users have access to.  They would also have the ability to delete all files that those users have access to. <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Recall from the last phase of our project that in order to make sure tokens are not tampered with by users, the group server signs the SHA-256 hash of the token that it is issuing, and includes that signed hash in the token itself. This is done by concatenating the server name, username, and alphabetically ordered list of groups a user is in. The file servers can then verify that their own computed hash (created by recreating the string) of the token matches the signed hash included in the token, after the signature is undone.  If they match, then the token has not been tampered with.  In order to make sure that the token’s issued by the group server are not stolen by file servers and given to other anyone that file server pleases, we can use the following procedure to ensure that stolen token’s will be of no use at any file other file server in the system other than the burglarizing file server. <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In order to achieve this, we can slightly modify the way in which tokens are created such that they will contain the IP address and port number of the file server a user wishes to access which can be used to uniquely identify which file server the token was originally intended to be sent to. We can use the IP address and port number combination because IP addresses are unique per machine and if two file servers are running on the same system they will have the same IP address but must be running on different ports. When a user first connects to the system, after mutually authenticating with the group server, the group server will ask the user if he/she will be accessing a file server (if no, they may only be wanting to change settings on the group server) upon which the system will prompt the user for the file server’s IP address and port number.  It will then add the two inputted strings to the token and hash and sign the token as it did before. This time however the hash will be made from the concatenated string of server name, username, IP address, port number, and the alphabetically sorted user groups all still separated with a null byte. Now when a file server opens the token, it can verify that the data has not been tampered by checking the signed hash as per before but now can check to ensure that the IP address and port contained in the users token is the same IP address and port number that that particular file server is running on. If either field or the signed hash don’t match, then we cannot be sure the token was not tampered with and thus can terminate the connection. We can use this to prevent file servers from stealing tokens that were intended for their server, distributing that token to other individuals, and having stolen tokens be successfully used on other servers. Each time a user leaves the group server or a file server, they will be prompted if they will be accessing a different file server next and if so what that IP address will be. With all of this functionality in place, our system can guarantee the integrity of tokens and that their contents have not been stolen or modified.

##Conclusion
---
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In conclusion, we have made the overall security of the system stronger by implementing the above protocols and methods. These additional implementations can be put into place such they will only extend the protection and safety of the system without compromising any of the previous put in place security measures. The original mutual authentication to the group server, token signature and verification process, file server authentication to the user, and encrypted sessions all remain intact with new functionality for protecting against replay/modification/reordering of messages within a session, providing users a way to safely store sensitive files on possible malicious file servers, and a way to ensure that tokens cannot be stolen and given holistically to another user. This new functionality only serves to make the system confidentiality and integrity stronger without interfering or effecting the core security functionality that was established and implemented during Phase 3. By adding shared counters between both servers and users, our system is no longer vulnerable to an attack that reorders messages, or an attack that replays messages. Likewise, we can detect message tampering by adding HMAC’s to every message sent between a server and a user. By editing the handshake between a file server and a user, our system is no longer vulnerable to replays of an entire session, while still maintaining the verification of the file server. By creating key chains and storing them in a Hash table we can now provide users with the ability to encrypt and decrypt files before they are stored on and when they are downloaded from file servers, all of which is done and managed from a new standalone serializable class GroupKeyList and a new message/response option. Finally by adding the two additional fields of a file server IP and port number we can correctly ensure that a token has not been stolen and was intended for a particular file server but still follow the previous procedure of taking the hash of the concatenated string of the tokens contents and then having the group server sign this hash with its private key. This ensures that the token has not been tampered or modified and will ensure that the IP and port number contained within that token were entered and stored there by the group server only.