##**1653 - Project - Phase 5**
###December 8th, 2016
---

##**Group information**
###Bryan Heim - bph11@pitt.edu
###Richard Dillon - rad114@pitt.edu
---

##Section 1: System Threat Model
---
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Our threat model will extend the current, cumulative threat models presented in Phase 3 and Phase 4 by removing some of the possible assumptions we had earlier made. We can again, like in previous phases, compartmentalize and characterize the different ways in which the individuals or machines involved in the system may or may not act. We can again classify these collections into the following four categories, each with their own assumptions for the final phase: .<br /><br />**Group Server:** The group server is will maintain the same trust as throughout the rest of the phases, namely that it is entirely trustworthy.  The group server will not save state about or share secrets with any of the individual file servers. The group server will be regularly updated<br /><br />**File Servers:** For the final phase, we are going to assume that file servers are more untrusted than in previous phases. File servers may attempt to modify or change the contents of individual files that are stored locally on its server<br /><br />**Clients:** We must still assume that clients will behavior in a manner that is untrustworthy, and more specifically that they may attempt to do any of the previous actions mentioned in previous phases, as well as attempting to continually enter commands or open multiple connections in an attempt to slow down the overall system and deny the availability of the system to legitimate users. However we will assume that clients will not leak the keychains, either the encryption/decryption or integrity, and that they will keep the keychains of the groups they belong to safe.<br /><br />**Other Principals:** The system can have active attackers who try to obtain data that they should not be allowed to access and in general will still continue to be actively malicious. Also we must consider the fact that there could be attackers who wish to overpower the computational power of the group server resulting in denial of services for actual clients who wish to interact with the system. 

##Section 2: Possible Attacks
---
###File Modification or Tampering  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thus far we have provided guarantees on the authenticity and integrity of users to file servers, and safely prevent a way from files being leaked. However, currently there are no mechanisms in place to enforce that the files themselves, once saved on an individual file server, have not had its contents modified in any way. If a fileserver can insert, change, or remove the data that is stored in particular files, it will cause file corruption.  If a file server is able to corrupt or modify the data, when a user goes to recover the file, the resulting decryption process currently implemented in the system would yield data that is largely mangled and malformed due to the use of CBC encryption/decryption. (Note: in the current system implementation files are stored on the file server encrypted by the uploader without revealing the secret key used to the file server). Users would not be able to easily and quickly verify the data that is contained within a downloaded file and therefore could waste time decrypting large files only to find that its original contents were changed. Some users may never even verify that all of the contents were successfully downloaded and properly decrypted. For example, if file servers make only small modifications at the end of very large files, this may go unnoticed by some users. By providing a means to verify the integrity of the file easily, we can ensure that users will know any time the files stored have been modified and that that particular file server cannot be trusted any longer. 

###Denial of Service
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;While we have protected our system against many threats this semester, one of the more prevalent threats has been ignored, denial of service.  A DoS attack is one of the easiest to execute, and can cause the entire system to be unavailable for legitimate users.  While a DoS attack really has no lasting changes or impact on a system, it can be quite annoying to deal with as almost anyone can carry it out if there is no defense mechanism in place.  This sort of attack is relatively easy to exploit in our system by either an authenticated user, or a third-party attacker.  By properly authenticating to any server within the system, a user can make bogus requests, such as adding a million fake users, or uploading a 1GB file on a thousand different connections.  Such an attack by a user cannot be thwarted in advance, as we have no idea as to the legitimacy of each user’s action on a server.  The only way to stop an attack like the one above is to identify which user was causing the server’s to crash, and punish them accordingly.  Alternatively, a third party attacker could simply make thousands of connection requests to a server.  Since either a group server or a file server has to carry out a computationally heavy handshake, either type of server would be too bogged down with illegitimate requests to properly service actual clients.  While there is no full proof way to prevent such an attack from occurring, there are counter measures that can be put in place to require more resources from the attacker.  If an attacker were required more resources than they have available to carry out the attack, then our system could potentially thwart many small attacks from taking place.  In the current state of our system, the first two messages involved in the group server’s handshake (not including public key exchanging and verification) are as follows: <br /> <p align="center">![alt text](https://github.com/Bryan-Heim/cs1653-2016fa-bph11-rad114/raw/master/images/HandshakeTwoLines.png "Figure 1")</p>If the client machine were to just send garbage (from a random number generator or otherwise) at the server, the server would generate a 256-bit AES key and 20 byte random number but would also have to encrypt that shared key with the users 4096-bit RSA public key (very computationally heavy).  A similar attack could be carried out against file servers, as they also use RSA encryption in their handshake.  The file server handshake is as follows: <br /> <p align="center">![alt text](https://github.com/Bryan-Heim/cs1653-2016fa-bph11-rad114/raw/master/images/T5Handshake.png "Figure 2")</p>A similar attack can be carried out due to the fact that when a file server receives a request, it will attempt to decrypt the information contained within the request by using its 4096-bit RSA private key. If the initial information sent by the client is a 648 character (do to Base64 encoding the encrypted 512 byte array), randomized string, the receiving file server will waste cycles attempting to decrypt garbage. This would increase the stress on the file server's CPU resulting is less opportunity to service legitimate user requests, thus causing a denial of service.

##Section 3: Section 3: Countermeasures for Attacks
---
By addressing that these two threats exist in the current state of the overall system, we can create countermeasures accordingly in order to protect the security of the system and increase the assurance placed within our system. For the two threats above we can enforce the following:  
###File Modification or Tampering
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In order to give users the ability to verify if a file was or was not successfully tampered with, we can utilize the methods of symmetric key cryptography and keyed-hash message authentication codes to provide means of quick and efficient data integrity. Currently individual users are members of various groups, and these groups already generate symmetric keys used for encrypting and decrypting the contents of files shared amongst that specific group. Each group has a “keychain” of symmetric 256-bit AES keys that are changed every time a user is either added or removed. We can apply this same methodology, also using 256-bit AES keys, in order to give groups corresponding file integrity key chains. In this way we are able to provide both file protection from leaked and file modification or tampering via malicious file servers. In the event that a user or group discovers either of these cases they can be fairly certain that the file server is not acting in a trustworthy manner and can discontinue use.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To accomplish the aforementioned policies we can utilize already existing functionality within the codebase and add modifications to ensure that the file integrity keychains of each individual group are kept safe on the group server. In the current form, GroupListKeys contains a Hashtable, with all group names that exist in the system as keys, which allows quick retrieve of a group’s confidentiality keychain. This “master” keychain is stored securely on the group server and each of the keys map to keychain objects. Contained within these objects are 256-bit AES keys used for encryption that are generated and added to an ArrayList of SecretKeys whenever a group is created, a user is added to that group, or a user is removed from that group. We can modify the keychain object such that it will maintain two ArrayLists and anytime we would create or add an encryption key, we can also do the same for a new integrity key and it add it to the new ArrayList being maintained in the keychain object. In this way, GroupListKeys will be able to maintain the file encryption and data integrity keys, all encapsulated within the keychain object. 	When a group is created, the first user is assigned a “start block” of 0, the index of the first key in the ArrayList stored for that group. The start and end blocks of each user are currently saved in two separate Hashtable structures that are contained within an individual user’s User object stored in the UserList. When a user is added to the group, a new encryption key is generated, a new integrity key is generated, and that user is assigned their start block equal to the current index of the ArrayList of SecretKeys. Likewise, when a user is removed from a group, their end block is set for that particular group and new keys are generated. Because the new integrity keys are added every time a new encryption key is added, we can reuse the same start and end blocks that are currently being saved for users. The start and end blocks are what allows the group server to construct a “partial” keychain which is a subset of the master keychain. The partial keychain is created differently for each user based on which groups that user was a part of and when the user was an active member. If the user is not able to access particular blocks/keys because he/she was not an active member at the time, the group server will instead insert a “-1” value to symbolize they do not have access to keys from that time for that group. The partial keychain is then passed to the user every time he/she gets a new token. Because we slightly modified the GroupKeysList to incorporate new integrity keys, we can create a partial integrity keychain every time a partial encryption keychain is created. When a user goes to request the token, the partial encryption keychain and partial integrity keychains are sent over to the user to be used when interacting with a file server. More specifically, these partial keychains allows users to determine which keys were used to decrypt a downloaded file and which key (the most current) should be used to upload new files.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; When uploading a file to a file server, the client machine will attempt to retrieve the most recent 256-bit AES confidentiality key and 256-bit AES integrity key from their two keychains.  They will then use the confidentiality key to encrypt the file that they wish to send to the file server, using a CBC Cipher with PKCS7 padding.  After that, the integrity key will be used to perform an HMAC on the unencrypted file to ensure that the file is not tampered with, using HmacSHA256 as an algorithm parameter.  When the client is finished performing the HMAC and encryption, the encrypted file along with the HMAC, are added to an envelope.  That envelope is then encrypted and sent to the file server.  Upon receiving the encrypted file and HMAC from the client, the file server will then store the file contents locally as well as a SharedFile instance for that particular file.  In that SharedFile, along with some other meta data (key number, IV used, group name, etc.) will be a field to store the HMAC bytes.  Here, the received HMAC will be stored in connection to the file that was sent over via the SharedFile object.  When downloading a file, the server will simply grab the SharedFile instance that is attached to the specified file, and send to the user the encrypted file contents as before and stored HMAC.  Upon receiving the envelope with the above specified information, the client will decrypt the file using the correct confidentiality key.  The client will then compute an HMAC on that decrypted file, again using the HmacSHA256 algorithm parameter.  The computed HMAC is compared to the received HMAC from the file server and if they match, then the client confirms that the file has not been tampered with.  If they do not match, then the client prints a message to the user warning them that the contents of the file have been tampered with.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;By adding an integrity keychain to the already existing structure of the system, we have thus provided more capabilities for users to determine whether or not a file server can be trusted. Users will be able to ensure that files cannot be leaked from file servers and if file servers attempt to modify the data contained in a file, the user will be able to determine this tampering and will thus have much more of an insight into whether or not a that file server can be trusted. Below is a diagram that represents what the master keychain data structure would appear as and what the encryption/integrity partial keychains that a user would receive when he/she requests and gets a token: <br /> <p align="center">![alt text](https://github.com/Bryan-Heim/cs1653-2016fa-bph11-rad114/raw/master/images/master-keychain-example-integrity.png "Figure 3")</p><br /> <p align="center">![alt text](https://github.com/Bryan-Heim/cs1653-2016fa-bph11-rad114/raw/master/images/user-keychain-example-integrity.png "Figure 4")</p> 

###Denial of Service
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;One approach to preventing a DoS attack is to require clients to do some work before a server will begin to do its own computational work associated with authentication.  By requiring clients to do work on their own systems before authenticating with a group or file server, we can decrease the amount of resources an attacker has to bog down the system.  For example, if an attacker has a machine that can make 1,000 connection requests per second to the server, and a server needs 1 second to process each request, then the balance of computational resources is clearly tipped in the attacker’s favor.  However, if we can make each connection request take the attacker more time to process, say 5 seconds in this example, then we can essentially tip the balance of computational resources in the server’s favor.  To accomplish this in our system, we can have the server generate puzzles to give to clients prior to a handshake protocol.  In order for a client to gain access to the system their machine must first solve the puzzle, which requires computational resources from the client to solve.  Only when the client gives a correct solution to the server will it be allowed to carry out the handshake and gain access to the system.  In order for puzzles to be a solution to the problem of resource balancing, we must ensure that any given puzzle is easy to generate, a solution to any puzzle be easy to verify by the server, and any puzzle be hard for the client to solve.  However, hard is relative to the client’s machine, so we assume that all clients are operating on a desktop with at least a 3.0GHz processor.  It is important to note here that the goal is to prevent the average attacker from bogging down our system, not a super computer or distributed network of computers. <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A particularly good puzzle to use for protection against a DoS attack is inverting a cryptographic hash function (e.g. SHA-256) because it has the properties of preimage resistance and second-preimage resistance.  By having these two properties, SHA-256 hashes cannot be effectively parallelized, which makes it a perfect candidate to be used as a computational puzzle.  There is also no other method to guess a hash other than brute force.  The puzzle works as follows.  First a random 16 bit number is chosen by the server, and padded with 240 1 bits.  That 256-bit number is then hashed by the server using SHA-256, to get a 256-bit hash value.  That value is then sent to the user, along with the number of bits that the client is to be searching for (16), and the encryption of those random 16 bits concatenated with the systems current time stamp.  The 16 bits and timestamp are encrypted with a 256-bit AES key that only the server knows.  The message sent from the server to the client is as follows: <br /> <p align="center">![alt text](https://github.com/Bryan-Heim/cs1653-2016fa-bph11-rad114/raw/master/images/puzzle1.png "Figure 4")</p> After the client receives this message, they can begin brute forcing the random 16 bits.  At each iteration, the new computed 16 bits is SHA-256 hashed and compared to the received SHA-256 hash from the server.  If they match, then the puzzle is complete, and the client can then send it back, along with the encrypted data that it received, to the server.  That message is depicted here: <br /> <p align="center">![alt text](https://github.com/Bryan-Heim/cs1653-2016fa-bph11-rad114/raw/master/images/puzzle2.png "Figure 5")</p> After the server receives the above message, it simply has to decrypt the timestamp and chosen 16 bits with its 256-bit AES key, and compare the unencrypted 16 bits to the 16 bits it received as plaintext.  If they match, then the client successfully completed the puzzle, and the handshake can begin.  If they don’t match, then it is assumed that the client will begin spamming messages, and the connection is dropped.